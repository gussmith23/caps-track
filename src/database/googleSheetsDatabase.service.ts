import {
  GoogleSpreadsheet,
  GoogleSpreadsheetRow,
  GoogleSpreadsheetWorksheet,
} from 'google-spreadsheet';
import { JWT } from 'google-auth-library';
import { readFile } from 'fs/promises';
import { Player } from '../player';
import { Game } from '../game';
import { getConfig } from '../config';
import { Point } from '../point';
import { Item } from '../item';
import { Font } from '../font';
import { Logger, Provider } from '@nestjs/common';
import { DatabaseService } from './database.service';
import { K } from 'handlebars';

// - testing_keyfile relative to config directory.
export function createGoogleSheetsProvider(
  testing_keyfile: string,
  testing_spreadsheet_id: string,
  readonly: boolean = false,
): Provider {
  return {
    provide: 'DATABASE',
    useFactory: async () => {
      let creds = JSON.parse(
        await readFile(__dirname + '/../../config/' + testing_keyfile, 'utf8'),
      );

      // Initialize auth - see https://theoephraim.github.io/node-google-spreadsheet/#/guides/authentication
      const serviceAccountAuth = new JWT({
        // env var values here are copied from service account credentials generated by google
        // see "Authentication" section in docs for more info
        email: creds.client_email,
        key: creds.private_key,
        scopes: [
          readonly
            ? 'https://www.googleapis.com/auth/spreadsheets.readonly'
            : 'https://www.googleapis.com/auth/spreadsheets',
        ],
      });

      let sheet_service = new GoogleSheetsService(
        new GoogleSpreadsheet(testing_spreadsheet_id, serviceAccountAuth),
      );
      await sheet_service.init();
      return sheet_service;
    },
  };
}

class GoogleSheetsService extends DatabaseService {
  getPlayerSchema(): Promise<string[]> {
    return this.playerSheet()
      .loadHeaderRow()
      .then(() => this.playerSheet().headerValues);
  }
  getGameSchema(): Promise<string[]> {
    return this.gameSheet()
      .loadHeaderRow()
      .then(() => this.gameSheet().headerValues);
  }
  getPointSchema(): Promise<string[]> {
    return this.getPointSheet()
      .loadHeaderRow()
      .then(() => this.getPointSheet().headerValues);
  }
  getItemSchema(): Promise<string[]> {
    return this.getItemSheet()
      .loadHeaderRow()
      .then(() => this.getItemSheet().headerValues);
  }
  getFontSchema(): Promise<string[]> {
    return this.getFontSheet()
      .loadHeaderRow()
      .then(() => this.getFontSheet().headerValues);
  }

  addPlayer(): Promise<string> {
    throw new Error('Method not implemented.');
  }
  getPlayer(): Promise<Player | undefined> {
    throw new Error('Method not implemented.');
  }
  getPoints(): Promise<Point[]> {
    return this.getPointSheet()
      .getRows()
      .then((rows) => rows.map(GoogleSheetsService.pointFromRow));
  }
  addPoints(points: Point[]): Promise<void> {
    let length = points.length;
    if (length === 0) {
      return Promise.resolve();
    }
    return this.getPointSheet()
      .addRows(
        points.map((point) => {
          return {
            gameId: point.gameId,
            double: point.double,
            datetime: point.datetime,
            playerId: point.playerId,
          };
        }),
      )
      .then((rows) => {
        if (rows.length !== length) {
          throw new Error('Failed to add all points');
        }
      });
  }

  private readonly logger = new Logger(GoogleSheetsService.name);

  constructor(private sheet: GoogleSpreadsheet) {
    super();
  }

  async init() {
    await this.sheet.loadInfo();
  }

  private static gameFromRow(row: GoogleSpreadsheetRow) {
    // TODO(@gussmith23): It feels like there should be a more TypeScript-y way
    // of doing this. Apparently get() can return undefined and there's no way
    // to make it fail if it does.
    let errorIfUndefined = (field: string) => {
      if (typeof row.get(field) === 'undefined') {
        throw new Error(`Game row is missing ${field}`);
      }
      return row.get(field);
    };
    return new Game(
      errorIfUndefined('id'),
      errorIfUndefined('player1'),
      errorIfUndefined('player2'),
      errorIfUndefined('player3'),
      errorIfUndefined('player4'),
      new Date(errorIfUndefined('beganAt')),
      row.get('endedAt') ? new Date(row.get('endedAt')) : undefined,
      row.get('name'),
    );
  }

  private static fontFromRow(row: GoogleSpreadsheetRow) {
    // TODO(@gussmith23): It feels like there should be a more TypeScript-y way
    // of doing this. Apparently get() can return undefined and there's no way
    // to make it fail if it does.
    let errorIfUndefined = (field: string) => {
      if (typeof row.get(field) === 'undefined') {
        throw new Error(`Player row is missing ${field}`);
      }
      return row.get(field);
    };
    return new Font(
      errorIfUndefined('id'),
      errorIfUndefined('name'),
      row.get('size'),
    );
  }

  private getFontSheet() {
    return this.sheet.sheetsByTitle['fonts'];
  }

  private getItemSheet() {
    return this.sheet.sheetsByTitle['items'];
  }

  private gameSheet() {
    return this.sheet.sheetsById[0];
  }
  private playerSheet() {
    return this.sheet.sheetsById[1272448402];
  }

  async addGame(
    player1id: string,
    player2id: string,
    player3id: string,
    player4id: string,
    beganAt: Date,
    endedAt?: Date,
    name?: string,
  ): Promise<string> {
    console.assert(
      new Set([player1id, player2id, player3id, player4id]).size == 4,
      'Players must be unique',
    );
    let sheet = this.gameSheet();
    return sheet.getRows().then((rows) => {
      // Using apply here because Math.max doesn't take an array. Weird that we
      // need to pass null. Blame JavaScript.
      let id =
        Math.max.apply(
          null,
          rows.map((row) => Number(row.get('id'))),
        ) + 1;
      let newGame = new Game(
        id,
        player1id,
        player2id,
        player3id,
        player4id,
        beganAt,
        endedAt,
        name,
      );

      // This promise ensures that the game is added to the sheet before the id is returned.

      return this.addGameToSheet(newGame, sheet).then((_) => id.toString());
    });
  }

  private async addGameToSheet(game: Game, sheet: GoogleSpreadsheetWorksheet) {
    let data = {
      id: game.id,
      player1: game.player1id,
      player2: game.player2id,
      player3: game.player3id,
      player4: game.player4id,
    };
    if (game.endedAt) {
      data['endedAt'] = game.endedAt;
    }
    if (game.beganAt) {
      data['beganAt'] = game.beganAt;
    }
    if (game.name) {
      data['name'] = game.name;
    }
    return sheet.addRow(data);
  }

  getAllPlayers(): Promise<any[]> {
    let sheet = this.playerSheet();
    return sheet.getRows().then((rows) =>
      rows.map((row) => {
        return GoogleSheetsService.playerFromRow(row);
      }),
    );
  }

  async getPlayersMap(): Promise<Map<string, Player>> {
    let sheet = this.playerSheet();
    return sheet.getRows().then(
      (rows) =>
        new Map(
          rows.map((row) => {
            let player = GoogleSheetsService.playerFromRow(row);
            return [player.id, player];
          }),
        ),
    );
  }

  async getGamesMap(): Promise<Map<string, Game>> {
    let sheet = this.gameSheet();
    return sheet.getRows().then(
      (rows) =>
        new Map(
          rows.map((row) => {
            let game = GoogleSheetsService.gameFromRow(row);
            return [game.id, game];
          }),
        ),
    );
  }

  async getGame(id: string) {
    if (id === undefined) {
      throw new Error('requested game id is undefined');
    }
    let sheet = this.gameSheet();
    return sheet
      .getRows()
      .then((rows) => rows.find((row) => row.get('id') == id))
      .then((row) => {
        if (typeof row === 'undefined') {
          return undefined;
        } else {
          return GoogleSheetsService.gameFromRow(row);
        }
      });
  }

  async getPlayers(ids: any[]) {
    if (ids.includes(undefined)) {
      throw new Error('one of the requested player ids is undefined');
    }
    let sheet = this.playerSheet();
    return sheet.getRows().then((rows) => {
      return ids.map((id) => {
        let row = rows.find((row) => row.get('id') == id);
        if (typeof row === 'undefined') {
          throw new Error(`player with id ${id} not found`);
        } else {
          return GoogleSheetsService.playerFromRow(row);
        }
      });
    });
  }

  async activeAndConcludedGames(): Promise<[any, any]> {
    let sheet = this.gameSheet();
    return sheet.getRows().then((rows) => {
      let pred = (row) => typeof row.get('endedAt') === 'undefined';
      return [
        rows.filter(pred).map(GoogleSheetsService.gameFromRow),
        rows.filter((row) => !pred(row)).map(GoogleSheetsService.gameFromRow),
      ];
    });
  }

  getPointSheet() {
    return this.sheet.sheetsById[537839588];
  }

  async endGame(gameId, datetime) {
    return this.isGameActive(gameId).then((isActive) => {
      if (!isActive) {
        throw new Error(`Game ${gameId} already ended`);
      } else {
        return this.gameSheet()
          .getRows()
          .then((rows) => rows.find((row) => row.get('id') == gameId))
          .then((row) => {
            if (typeof row === 'undefined') {
              throw new Error(`Game ${gameId} not found`);
            }
            row.set('endedAt', datetime);
            return row.save();
          });
      }
    });
  }

  async addPoint(gameId, playerId, double, datetime) {
    let pointSheet = this.getPointSheet();
    return this.isGameActive(gameId).then((isActive) => {
      if (!isActive) {
        throw new Error('Game is not active');
      } else {
        return pointSheet.addRow({
          gameId: gameId,
          double: double,
          playerId: playerId,
          datetime: datetime,
        });
      }
    });
  }

  // TODO(@gussmith23): Batch-removing like this does not seem to work. I think
  // it has to do with the google-spreadsheets library or the Google API. It
  // seems like removing row objects without awaiting them in between (i.e.
  // doing a bunch of removals and returning them with Promises.all) causes bugs
  // like removing unintended rows. I must be misunderstanding something about
  // how the library works.
  //
  // TODO(@gussmith23): Could clean up this iterface; e.g. could just pass # of points to remove per player.
  // async removePoints(
  //   events: { gameId: string, event: string, datetime: Date, playerId: string }[]
  // ) {
  //   // Sorting may not even matter at this point?
  //   events.sort((a, b) => { return new Date(a.datetime).getTime() - new Date(b.datetime).getTime() });
  //   if (events.length === 0) {
  //     return;
  //   }
  //   let gameId = events[0].gameId;
  //   if (events.some(event => event.gameId !== gameId)) {
  //     // Doesn't have to be true, I'm just implementing this lazily for now. And this is the common case.
  //     throw new Error("gameId must be the same for all events");
  //   }
  //   for (let event of events) {
  //     if (event.event !== "remove") {
  //       throw new Error("event must be remove");
  //     }
  //   }

  //   // Compute a map from playerId to the number of points to remove for that player.
  //   let pointsToRemove = new Map();
  //   for (let event of events) {
  //     if (!pointsToRemove.has(event.playerId)) {
  //       pointsToRemove.set(event.playerId, 0);
  //     }
  //     pointsToRemove.set(event.playerId, pointsToRemove.get(event.playerId) + 1);
  //   }

  //   let pointSheet = this.getPointSheet();
  //   return this.isGameActive(gameId).then(isActive => {
  //     if (!isActive) {
  //       throw new Error("Game is not active");
  //     }
  //     else {
  //       return pointSheet.getRows().then(rows => {
  //         let sortedRows = rows.filter(row => row.get('gameId') == gameId).sort((a, b) => a.get('datetime') - b.get('datetime'));
  //         let promises = [];

  //         for (let [playerId, numToRemove] of pointsToRemove) {
  //           let filteredRows = sortedRows.filter(row => row.get('playerId') == playerId);
  //           this.logger.debug(`${filteredRows.slice(-numToRemove).length}`);
  //           filteredRows.slice(-numToRemove).forEach(row => promises.push(row.delete()));
  //         }
  //         this.logger.debug("done generating promises");
  //         return Promise.all(promises);
  //       });
  //     }
  //   });
  // }

  /// Removes latest point from specified player in specified game.
  async removePoint(gameId, playerId) {
    let pointSheet = this.getPointSheet();
    return this.isGameActive(gameId).then((isActive) => {
      if (!isActive) {
        throw new Error('Game is not active');
      } else {
        return pointSheet.getRows().then((rows) => {
          let sortedRows = rows
            .filter(
              (row) =>
                row.get('gameId') == gameId && row.get('playerId') == playerId,
            )
            .sort(
              (a, b) =>
                new Date(a.get('datetime')).getTime() -
                new Date(b.get('datetime')).getTime(),
            );
          if (sortedRows.length) {
            // We can use ! to avoid the undefined check here because of the
            // length check above.
            return sortedRows.pop()!.delete();
          }
        });
      }
    });
  }

  /// returns score in the form
  /// [team 1 score (player1+player3), team 2 score (player2+player4),
  ///  player 1 score, player 2 score, player 3 score, player 4 score]
  async getScore(gameId) {
    let pointSheet = this.getPointSheet();
    let game = this.getGame(gameId);
    let pointRows = pointSheet
      .getRows()
      .then((rows) => rows.filter((row) => row.get('gameId') == gameId));
    return Promise.all([game, pointRows]).then(([game, pointRows]) => {
      return pointRows.reduce(
        (acc, row) => {
          let id = row.get('playerId');
          if (id === undefined) {
            throw new Error('playerId is undefined');
          }
          if (
            ![
              game.player1id,
              game.player2id,
              game.player3id,
              game.player4id,
            ].includes(id)
          ) {
            throw new Error(`playerId ${id} not in game ${gameId}`);
          }
          if (id === game.player1id) {
            acc[0] += 1;
            acc[2] += 1;
          }
          if (id === game.player2id) {
            acc[1] += 1;
            acc[3] += 1;
          }
          if (id === game.player3id) {
            acc[0] += 1;
            acc[4] += 1;
          }
          if (id === game.player4id) {
            acc[1] += 1;
            acc[5] += 1;
          }
          return acc;
        },
        [0, 0, 0, 0, 0, 0],
      );
    });
  }

  async getPhrases() {
    let sheet = this.sheet.sheetsById[1119588355];
    return sheet.getRows().then((rows) => rows.map((row) => row.get('phrase')));
  }

  async renameGame(gameId: number, gameName: string) {
    let sheet = this.gameSheet();
    return sheet.getRows().then((rows) => {
      let filtered = rows.filter((row) => row.get('id') === gameId);
      if (filtered.length === 0) {
        throw new Error(`Game with id ${gameId} not found`);
      }
      if (filtered.length > 1) {
        throw new Error(`Multiple games with id ${gameId} found`);
      }
      let row = filtered[0];

      row.set('name', gameName);
      return row.save();
    });
  }

  // Returns
  // - Map from player id to [points scored, doubles scored].
  async getInterestingStats(): Promise<any> {
    let playerSheet = this.playerSheet();

    return Promise.all([
      this.playerSheet().getRows(),
      this.gameSheet().getRows(),
      this.getPointSheet().getRows(),
    ]).then(([playerRows, gameRows, pointRows]) => {
      // Rank players by points scored.

      // Points, with doubles/triples/etc computed.
      let processedPoints = Point.computeDoubles(
        pointRows.map(GoogleSheetsService.pointFromRow),
      );

      // Maps player id to a map from point type (nonneg integer) to number of
      // points of that type. (0 = single, 1 = double, 2 = triple, etc.)
      let playersToPointTypeMap = new Map();
      for (let point of processedPoints) {
        if (typeof point.double !== 'number') {
          throw new Error('point.double is not a number');
        }
        if (!playersToPointTypeMap.has(point.playerId)) {
          playersToPointTypeMap.set(point.playerId, new Map());
        }
        let playerMap = playersToPointTypeMap.get(point.playerId);
        if (!playerMap.has(point.double)) {
          playerMap.set(point.double, 0);
        }
        playerMap.set(point.double, playerMap.get(point.double) + 1);
      }

      // Set of point types present. e.g. [0, 1] would indicate that only
      // singles and doubles are present in all the data.
      let allPointTypes = new Set();
      for (let [_, playerMap] of playersToPointTypeMap) {
        for (let pointType of playerMap.keys()) {
          allPointTypes.add(pointType);
        }
      }

      // Generate a map from point type to a list of [playerId, points of that
      // type], sorted by points.
      let pointTypeToSortedPlayersAndPoints = new Map();
      for (let pointType of allPointTypes) {
        let players = Array.from(playersToPointTypeMap.entries()).map(
          ([playerId, playerMap]) => {
            let points = playerMap.get(pointType);
            if (points === undefined) {
              points = 0;
            }
            return [playerId, points];
          },
        );
        pointTypeToSortedPlayersAndPoints.set(
          pointType,
          players
            .filter(([_, points]) => points > 0)
            .sort((a, b) => b[1] - a[1]),
        );
      }

      return pointTypeToSortedPlayersAndPoints;
    });
  }

  async getItemsMap(): Promise<Map<string, Item>> {
    let sheet = this.getItemSheet();
    return sheet.getRows().then(
      (rows) =>
        new Map(
          rows.map((row) => {
            let item = GoogleSheetsService.itemFromRow(row);
            return [item.id, item];
          }),
        ),
    );
  }

  async getFontsMap(): Promise<Map<string, Font>> {
    let sheet = this.getFontSheet();
    return sheet.getRows().then(
      (rows) =>
        new Map(
          rows.map((row) => {
            let font = GoogleSheetsService.fontFromRow(row);
            return [font.id, font];
          }),
        ),
    );
  }

  private static itemFromRow(row: GoogleSpreadsheetRow) {
    // TODO(@gussmith23): It feels like there should be a more TypeScript-y way
    // of doing this. Apparently get() can return undefined and there's no way
    // to make it fail if it does.
    let errorIfUndefined = (field: string) => {
      if (typeof row.get(field) === 'undefined') {
        throw new Error(`Player row is missing ${field}`);
      }
      return row.get(field);
    };
    return new Item(
      errorIfUndefined('id'),
      errorIfUndefined('name'),
      errorIfUndefined('icon'),
      errorIfUndefined('price'),
      errorIfUndefined('location'),
    );
  }

  private static playerFromRow(row: GoogleSpreadsheetRow) {
    // TODO(@gussmith23): It feels like there should be a more TypeScript-y way
    // of doing this. Apparently get() can return undefined and there's no way
    // to make it fail if it does.
    let errorIfUndefined = (field: string) => {
      if (typeof row.get(field) === 'undefined') {
        throw new Error(`Player row is missing ${field}`);
      }
      return row.get(field);
    };
    let unlockedItemIds = row.get('unlockedItemIds');
    if (unlockedItemIds !== undefined)
      unlockedItemIds = unlockedItemIds.split(',').map((id) => id.trim());
    else unlockedItemIds = [];
    let equippedItemIds = row.get('equippedItemIds');
    if (equippedItemIds !== undefined)
      equippedItemIds = equippedItemIds.split(',').map((id) => id.trim());
    else equippedItemIds = [];
    for (let id of equippedItemIds) {
      if (!unlockedItemIds.includes(id)) {
        throw new Error(
          `Player has equipped item ${id} but does not have it unlocked`,
        );
      }
    }
    return new Player(
      errorIfUndefined('id'),
      errorIfUndefined('name'),
      row.get('nameColor'),
      row.get('fontId'),
      row.get('fontWeight'),
      unlockedItemIds,
      equippedItemIds,
    );
  }

  private static pointFromRow(row: GoogleSpreadsheetRow) {
    // TODO(@gussmith23): It feels like there should be a more TypeScript-y way
    // of doing this. Apparently get() can return undefined and there's no way
    // to make it fail if it does.
    let errorIfUndefined = (field: string) => {
      if (typeof row.get(field) === 'undefined') {
        throw new Error(`Player row is missing ${field}`);
      }
      return row.get(field);
    };
    let double = row.get('double');
    if (double === 'TRUE') {
      double = true;
    } else if (double === 'FALSE') {
      double = false;
    } else {
      throw Error(`Unexpected value for double field: ${double}`);
    }
    return new Point(
      errorIfUndefined('gameId'),
      double,
      new Date(errorIfUndefined('datetime')),
      errorIfUndefined('playerId'),
    );
  }
}
